BDD and Cucumber
Behavior Driven Development
18 Oct 2017
Tags: BDD, cucumber

Matthew Mayer
Software Engineer person
matthewkmayer@gmail.com
https://matthewkmayer.github.io
@motoblag

* Slides available on GitHub

.link https://github.com/matthewkmayer/talks https://github.com/matthewkmayer/talks

- the "k" is important in the URL
- *bdd-cucumber* directory

* Who am I?

- Jack of all trades
- Written, implemented and maintained microservices in the cloud
- Super keen on agile software development

* What are we doing?

- What's BDD
- Cucumber?
- In action

* What's BDD?

*Behavior* *Driven* *Development* is hard to discuss without bringing up *Test* *Driven* *Development* (TDD).

* Test driven development

Short cycle of:

- Write a test
- Run all tests, see new test fail
- Code just enough to make the test pass
- Run all tests, see new test pass
- Refactor

* Test driven development

Red-green-refactor may be an easier way to remember it

* Spectrum of Test Driven Development

Rigorous following of red-green-refactor to "test-first" development to "tests after" (or tests never).

* The boon of Test Driven Development

- Tests don't get missed (story time on missing tests)
- Code is inherently easily testable
- Code comments: easier to focus on commenting *why* not *what*

* Behavior means functionality

* Stepping up the stack

Shared language

* Stepping up the stack

Why test the *functionality* of code?

.link https://i.imgur.com/qrIJyor.gifv

* Right level of abstraction

Not many people speak unit tests.

Desired behavior is easier to convey.

* Test reuse

Verify changes, big or small

* Focus on the what, not the how

Test outward-facing behavior

* Black box testing

These functional level tests interact with the system under test at its boundaries.

How the behavior is implemented doesn't matter: could be software, a trained pet, letting cosmic rays flip bits, etc...

* Go/no go

Catch incorrect behavior at the system's input and output layers

* But, unit tests!

Unit tests can't perform the same role as functional/behavior tests.

A test interacting with the system at its input and output layers is not a unit test.

* How to do it

Use a tool with Behavior Driven Development in mind

* Cucumber!

* Speaking the language

Gherkin format:

    Given
    When
    Then

* Gherkin example

    Given I'm logged in to Twitter
    When I send a tweet
    Then the tweet is shown on my list of tweets

* Execution

Can't get away from actually writing code.

    Given /^I'm logged in to Twitter$/ do
        url = URI.parse('https://api.twitter.com/1.1/statuses/update.json')
        tweet_to_send = Net::HTTP::Post.new(url.to_s)
        tweet_to_send.body = {status: 'A test tweet'}
        Net::HTTP.start(url.host, url.port) {|http| http.request(tweet_to_send)}
    end

* Execution

With the Cucumber tool installed, execution is easy:

    cucumber

* DIY from scratch

- Install cucumber:
    gem install cucumber
- Have cucumber set up the files it needs:
    cucumber --init
- Write a Gherkin scenario with steps
- Implement the step definitions

* DIY level 0

Write the behavior/functional tests first

* DIY level 1

Add cucumber to build pipeline: run the cucumber tests automatically, on every build

* DIY level 2

After a deployment, run the cucumber tests against the deployed software

* Code and deploy with confidence